https://www.youtube.com/watch?v=F7EnW8dfetU 

# DDD, Boris and Snap-E
- DDD
  - 왜 DDD/MSA인가 ?
    - common language의 역할
      - communication cost minimize
      - 작은 변화 싸이클을 유도
      - 개발자/비개발자의 도메인 영역을 일치시킬 수 있음
        - 개발자는 비개발자에 비해 도메인 전문 지식이 부족하다.
        - 비개발자는 개발자에 비해 IT 관련 지식이 부족하다.
        - 서로의 언어를 고집하기 보다는 "도메인"에 대해서 이야기할 수 있다.
          - ex) 응시자는 응시중 다른 시험을 시작할 수 있습니까 ?
  - Event Storming
    - 정의
      - IT와 Business의 align
      - MSA design에서 domain과 subDomain을 구분할 수 있다.
    - 구성 요소
      - Domain Events
        - 알림 혹은 상태 전이
        - 과거형/수동형으로 표현
      - Command
        - 요청 혹은 트리거
        - 도메인 이벤트의 발생지(source)
      - Aggregate 
        - 한 개 혹은 그 이상의 entity로 구성
        - Aggregate끼리는 루즈 커플링(오브젝트 탐색이 불가능, id로 식별)
      - Command -> Aggregate -> Domain Event 동작 (Aggregate와 Domain Event 사이에서는 원자성을 보존되어야함.)
        1. Add Item to Card
        2. Item
        3. Item Added to Cart
- Boris
  - 설계 내용(Aggregate, Domain)을 기술적 구현으로 표현
  - 동기/비동신 통신, 외부 통신 등
- Snap-E
  - Aggregate의 상세 스펙
    - API, DATA, STORY, RISK, UI 등


# 1.1 도메인 이란 ?
> 소프트웨어로 해결하고자 하는 문제 영역

# 1.2 도메인 전문가와 개발자 간 지식 공유
> 개발자도 도메인 지식을 갖추면 올바른 제품을 개발할 확률이 높아진다.

# 1.3 도메인 모델
> 도메인을 개념적으로 표현한 것

# 1.4 도메인 모델 패턴
- 애플리케이션 아키텍처 구성
  1. 사용자 인터페이스 혹은 표현 (Presentation)
     - 사용자의 요청을 처리하고 사용자에게 정보를 보여준다. 여기서 사용자는 소프트웨어를 사용하는 사람뿐만 아니라 외부 시스템일 수도 있다. 
  2. 응용 (Application)
     - 사용자가 요청한 기능을 실행한다. 업무 로직을 직접 구현하지 않으며 도메인 계층을 조합해서 기능을 실행한다. 
  3. 도메인 (Domain)
     - 시스템이 제공할 도메인 규칙을 구현한다. 
  4. 인프라스트럭쳐(Infrastructure) 
     - 데이터베이스나 메시징 시스템과 같은 외부 시스템과의 연동을 처리한다.

# 1.5 도메인 모델 도출
> 핵심 구성요소, 규칙, 기능을 찾아 도메인 모델을 구성한다.

# 2.1 네 개의 영역
1. 표현
   - 요청에 대한 응답을 반환하는 역할
     - 웹 브라우저를 사용하는 사람, REST API를 호출하는 시스템 등
2. 응용
   - 도메인 로직의 위임자 
3. 도메인
   - 도메인 핵심 로직 구현 
4. 인프라스트럭처 
   - 논리적 개념이 아닌 기술적 구현
     - RDBMS, SMTP, 외부 HTTP 서비스 호출 등 
# 2.2 계층 구조 아키텍처
> 표현 > 응용 > 도메인 > 인프라스트럭처
- 상위 계층에서 하위 계층으로의 의존만 존재하고 하위 계층은 상위 계층을 의존하지 않는다.
- 엄격한 계층 구조는 바로 아래의 계층에 대한 의존만 가지지만, 때로는 편리함을 위해 손자 계층에 의존하기도 한다.

# 2.3 DIP
> Dependency Inversion Principle(의존 역전 원칙)
- 인터페이스를 통해 계층적 의존을 거스를 수 있다.
  - 저수준 모듈이 고수준 모듈에 의존함.
  - driver(상향 테스트) & stub(하향 테스트)
  - 고수준 모듈에서 사용할 저수준 모듈의 의존 주입을 전달 받을 수 있다.
  - 저수준 모듈이 준비 되지 않아도 고수준 모듈에 대한 검증 테스트를 진행할 수 있다.
  - **하위 기능을 추상화한 인터페이스는 고수준 모듈 관점에서 도출해야한다.**
  - DIP가 적용된 아키텍처에서는 인프라스트럭처 영역이 도메인/응용 영역에 의존(상속)하는 구조가 된다.
    - DBMS(Mybatis, JPA 등), SMS(문자/메일)과 같은 인프라스트럭처 구현체를 갈아끼우는 방식으로 구현 기술을 변경할 수 있다.
# 2.4 도메인 영역의 주요 구성요소
  - ENTITY
    - 고유 식별자를 갖는 객체로 자신의 라이프 사이클을 갖는다. 
  - VALUE
    - 고유 식별자를 갖지 않는 객체로 개념적인 값을 표현할 때 사용된다. 
  - AGGREGATE
    - 연관된 엔티티와 밸류 객체를 개념적으로 묶은 것이다. 
  - REPOSITORY 
    - 도메인 모델의 영속성을 처리한다. 
  - DOMAIN SERVICE 
    - 특정 엔티티에 속하지 않는 도메인 로직을 제공한다. (여러 엔티티와 밸류를 필요로 하는 도메인 로직)

### 도메인 모델의 엔티티와 DB 관계형 모델의 엔티티의 차이점
> 도메인 모델의 엔티티는 데이터와 도메인 기능을 함께 제공하는 객체이다.
> 도메인 모델의 엔티티는 개념적인 표현을 밸류 타입으로 묶어서 표현할 수 있다.

### 애그리거트
> 연관 엔티티 객체의 군집
> 루트 엔티티를 통해 간접적으로 내부의 다른 엔티티나 밸류 객체에 접근한다. (애그리거트 내부 구현을 숨겨서 캡슐화할 수 있다.)
 
### 리포지터리
> 애그리거트 단위로 저장하고 조회한다.

# 2.5 요청 처리 흐름
> 표현 > 응용 서비스 > 도메인 

# 2.6 인프라스트럭처 개요
> DIP를 강요할 필요는 없다. 무조건적인 인프라스트럭처 의존을 없애기보다는 편리함이 큰 부분은 의존적으로 사용하는 것이 편할때도 있다.(스프링의 @Transactional)

# 2.7 모듈 구성
- 계층별 구성
  - 표현/응용/도메인/인프라스트럭처로 구분한 모듈 구조
- 도메인별 구성
  - 도메인 마다 표현/응용/도메인/인프라스터럭처를 포함하는 모듈 구조(도메인이 클 경우)
- 하위 도메인을 하위 패키지로 구성
  - 도메인별 구성에서 여러 개의 하위 도메인을 상위 도메인 영역에 포함시키는 모듈 구조

# 3.1 애그리거트
- 연관된 모델들을 군집한 상위 모델
- 일반적으로 "A has B"이면 애그리거트에 속하지만, 그렇지 않은 경우도 있다. (라이프 사이클의 책임자가 다를 경우, 서로가 서로의 변경에 영향을 미치지 않는 경우)
- 두 개 이상의 엔티티로 구성되는 애그리거트는 드물다.

# 3.2 애그리거트 루트
> 애그리거트에 속한 모든 객체가 도메인 규칙에 위배되지 않는 일관된 상태를 유지해야한다. 그 주체가 애그리거트 루트이다.
- 애그리거트 외부에서 애그리거트 내부 객체를 직접 변경하면 안 된다.
- 애그리거트 내부 객체를 조합해서 애그리거트 루트 기능을 완성한다.
- 한 트랜잭션에서는 한 애그리거트만 수정하는 것을 원칙으로 한다. (애그리거트끼리 변화를 전파하지 않는다.)
  - 단, 다음과 같은 경우는 한 트랜잭션에서 두 개 이상의 애그리거트 변경을 고려할 수 있다.
    1. 팀 표준 : 조직의 표준에 따라 사용자 유스케이스의 관련된 응용 서비스의 기능을 한 트랜잭션으로 실행해야 하는 경우가 있다.
    2. 기술 제약 : 기술적으로 이벤트 방식을 도입할 수 없는 경우 한 트랜잭션에서 다수의 애그리거트를 수정해서 일관성을 처리해야 한다.
    3. UI 구현의 편리 : 운영자의 편리함을 위해 주문 목록 화면에서 여러 주문의 상태를 한 번에 변경하고 싶을 것이다. 이 경우 한 트랜잭션에서 여러 주문 애그리거트의 상태를 변경해야 한다.

# 3.3 리포지터리와 애그리거트
> 애그리거트의 루트의 영속성을 표현하는 리포지터리는 하나만 존재해야하며, 해당 리포지터리는 루트 애그리거트의 하위 객체에 대한 완벽한 영속성을 보장해야한다.

# 3.4 ID를 이용한 애그리거트 참조
- 루트 애그리거트간의 참조는 개발자에게 편리함을 제공하지만 아래와 같은 문제를 야기할 수 있다.
  1. 편한 탐색 오용
     - 직접 참조로 인해 한 트랜잭션에서 다른 애그리거트를 수정하고 싶은 유혹에 쉽게 빠질 수 있다.
  2. 성능에 대한 고민
     - 연관 엔티티의 즉시/지연 로딩에 대한 고민
  3. 확장의 어려움
     - 부하가 많아지고 하위 도메인마다 서로 다른 DBMS를 사용하게 될 경우, JPA와 같은 단일 기술을 사용할 수 없다.
> 객체 참조가 아닌 ID 참조를 통해 간접적인 참조를 구현한다.

- N+1 문제를 대응하기 위해 DAO를 만들어 한 번의 조인 쿼리를 만들어 필요한 데이터를 로딩한다.

# 3.5 애그리거트 간 집합 연관
- 1-N 연관에서 1에서의 기능은 성능 문제를 야기할 수 있으니 N에서의 기능으로 대체한다.
- 실제 모델링에서 도출된 연관이라도 구현에 반영해야할지는 고민해보는 것이 좋다.

# 3.6 애그리거트를 팩토리로 사용하기
- 팩토리 메소드를 통해 중요한 도메인 로직을 한 곳에서 처리해 응집도를 높일 수 있다. 도메인에서 판단할 수 있는 문제는 도메인에서 이루어지고 응용 서비스는 도메인 로직을 알 필요가 없다.

# 4.1 JPA를 이용한 리포지터리 구현
- 모듈 위치
  - 가능하면 인프라스트럭처 영역에 위치시켜서 의존을 낮춘다.
- 리포지터리 기능
  - 조회
  - 추가
  - 삭제
    - 삭제 기능은 데이터를 실제로 삭제하지 않는 경우도 있다. (flag 활용)
# 4.2 스프링 데이터 JPA를 이용한 리포지터리 구현 
- 엔티티에서 사용되는 클래스들의 기본 생성자는 왠만하면 공개하지 않는다.
# 4.3 매핑 구현
- JPA 매핑 처리를 AccessType.PROPERTY가 아닌 AccesType.FILED로 하여 불필요한 get/set 메서드를 줄인다.
- AttributeConverter를 사용해 엔티티 클래스와 컬럼 데이터 간의 변화를 처리할 수 있다.
- 밸류 타입에 @EmbeddedId를 사용해 식별자로 매핑할 수 있다.
  - 식별자에 기능을 추가할 수 있다.
- 라이프 사이클, 데이터 변경의 책임자, 관계의 독립성등을 따져봐서 애그리거트에 존재하는 루트 엔티티 이외의 엔티티가 진짜 엔티티인지 의심해봐야 한다.
- 애그리거트 간 집합 연관은 최대한 피하는 것이 좋으나, 요구사항의 구현에 이득이 있다면 ID를 통한 간접참조로 구현한다.
# 4.4 애그리거트 로딩 전략
- 즉시 로딩 vs 지연 로딩을 따져본다고 하지만 지연 로딩을 기본값으로 가져가는게 더 편한 것 같다.
# 4.5 애그리거트의 영속성 전파
- 애그리거트는 완전한 상태이므로 연관된 엔티티들은 애그리거트 루트의 라이프 사이클에 종속되어야 한다.
# 4.6 식별자 생성 기능
- 사용자가 직접 생성
- 도메인 로직으로 생성
- DB를 이용한 일련번호
# 4.7 도메인 구현과 DIP
- JPA 어노테이션을 이용해 도메인에 인프라스터럭쳐 기술을 직접 사용하고 있다.
  - **도메인 모델에 대한 인프라 구현은 타협하더라도 합리적이다.**
    - RDBMS를 사용하다가 몽고 DB를 사용할까 ?
    - JPA를 사용하다가 Mybatis를 사용할까 ?
# 5 스프링 데이터 JPA를 이용한 조회 기능
- CQRS(Command and Query Responsibility Segregation) 
  - 명령과 조회의 책임 분리
# 5.2 검색을 위한 스펙
- Spefication<T> 인터페이스을 이용해여 조건을 기술할 수 있는 메소드 제공
# 5.3 스프링 데이터 JPA를 이용한 스펙 구현
- 스프링 데이터 JPA에서 제공하는 Specifiaction 인터페이스의 toPredicate 메소드 활용
- 함수형 인터페이스이므로 다양한 조건식을 anonymous 함수를 이용해서 조합해 사용한다.
# 5.4 리포지터리/DAO에서 스펙 사용하기
- 스펙 인터페이스를 파라미터로 갖는 findAll 메소드를 사용할 수 있다.
# 5.5 스펙 조합
- 스펙 인터페이스에서 제공하는 and 및 or 메소드를 사용해 조건을 조합할 수 있다.
- where 메소드를 사용해 nullable 조건을 편하게  처리할 수 있다.
# 5.6 정렬 지정하기
- 메소드명을 통해 정렬을 지정하거나 Sort를 인자로 전달할 수 있다.
# 5.7 페이징 처리하기
- PageRequest를 Pageable 파라미터로 전달해 페이징을 구현한다.
# 5.8 스펙 조합을 위한 스펙 빌더 클래스
- 다양한 스펙을 조합해서 사용할 경우 스펙 빌더를 만들어서 함수 체인으로 스펙을 조합하면 가독성이 좋고 단순한 구조를 유지할 수 있다.
# 5.9 동적 인스턴스 생성
- 조회 전용 모델을 만들어 객체 기준으로 쿼리를 작성하면서 지연/즉시 로딩에 대한 고민 없이 원하는 모습으로 데이터를 조회할 수 있다.
# 5.10 하이브네이트 @Subselect 사용
- 조회 결과를 Entity로 매핑하여 사용할 수 있다.
  - @Immutable
    - 조회 결과에 대한 매핑이므로 변경이 불가능함.
  - @Synchronize({"purchase_order", "order_line", "product"})
    - 연관 테이블의 상태 변경에 따라 조회 결과가 다를 수 있으므로 명시된 연관 테이블에 대한 변경이 있을 경우 flush 호출.
# 6 응용 서비스와 표현 영역
# 6.2 응용 서비스의 역할
- 응용 서비스가 도메인 로직을 일부 구현하면 코드 중복, 로직 분산 등 코드 품질에 안 좋은 영향을 줄 수 있다.
  1. 코드 응집도가 떨어진다. (도메인 로직 분석을 위해 파악해야할 부분이 많아짐.)
  2. 중복 로직이 발생한다. (여러 서비스에서 중복 사용되는 로직이 생길 수 있다. 도메인에 존재하면 서비스는 해당 로직을 호출만 하면 된다.)
# 6.3 응용 서비스의 구현
  1. 한 클래스에 관련된 도메인의 모든 기능 구현하기
     - 장점 : 높은 응집도, 중복 코드 예방
     - 단점 : 클래스의 크기가 커진다.
  2. 긴으별로 응용 서비스 클래스를 구현하기
     - 장점 : 코드 품질 유지
     - 단점 : 중복코드 발생의 여지(공통된 로직은 별도 클래스에 구현해서 예방 가능)
 - 응용 서비스의 인터페이스는 좋은 선택이라고 볼 수 없다. 
   - 응용 서비스는 런타임에 교체하는 경우가 거의 없다.
   - 응용 서비스의 구현 클래스가 두 개 이상인 경우는 드물다.
 - 응용 서비스에서 애그리거트 자체를 리턴하면 도메인 로직 실행을 응용/표현 영역 두 곳에서 할 수 있게 된다.
   - 코드의 응집도가 낮아진다.
   - 응용 서비스는 표현 영역에서 필요한 데이터만 리턴하는 것이 응집도를 높이는 확실한 방법이다.
 - 응용 서비스에 표현 영역의 데이터를 전달하거나 리턴하지 않도록 주의한다.
# 6.4 표현 영역
  - 표현 영역의 책임
    1. 사용자가 시스템을 사용할 수 있도록 알맞은 흐름을 제공한다.
    2. 사용자의 요청에 맞게 응용 서비스에 기능 실행을 요청한다.
# 6.5 값 검증
  - 표현 영역 : 필수 값, 갑의 형식, 범위 등을 검증한다.
  - 응용 서비스 : 데이터의 존재 유무와 같은 논리적 오류를 검증한다.
# 6.6 권한 검사
  - 다음 세곳에서 권한 검사를 수행할 수 있다.
    1. 표현 영역
       - 인증 유무
    2. 응용 서비스
       - 스프링 AOP를 활용한 메소드 단위의 권한 검사
    3. 도메인
       - 프레임 워크 기능을 확장해서 구현할 수 있지만 복잡하다.
# 6.7 조회 전용 기능과 응용 서비스
  - 조회 전용 기능은 표현 계층에서 바로 사용해도 문제가 없다. 
    - 트랜 잭션이 필요하지 않다.
    - 추가 로직이 없다.
    - 그래도 잘 모르겠다.
      1. 로직이 언제 추가될줄 알고 ? 조회 기능도 추가 로직이 있을 수 있지 않을까 ?
      2. 결국 컨트롤러가 리포지터리를 알고 있으면 트랜잭션 로직을 언제든 호출할 수 있는거 아닌가?
# 7 도메인 서비스
# 7.1 여러 애그리거트가 필요한 기능
  - 한 애그리거트에 넣기 애매한 도메인 로직을 억지로 특정 애그리거트에 구현하면 안 된다.
    - 자신의 책임 범위를 넘어서는 기능을 구현할 수 있다.
    - 외부 의존이 높아진다.
    - 코드를 복잡하게 만든다.
    - 애그리거트의 범위를 넘어서는 도메인 개념이 애그리거트에 숨어들어 명시적으로 드러나지 않는다.
    > 복잡한 애그리거트의 도메인 기능을 별도 서비스로 구현한다.
  
# 7.2 도메인 서비스
  - 애그리거트와 비교 했을 때, 도메인 서비스는 상태 없이 로직만 구현한다.
  - 도메인 서비스를 사용하는 주체는 애그리거트가 될 수도 있고 응용 서비스가 될 수도 있다.
  - 도메인 서비스는 도메인과 같은 패키지에 존재한다.
  - 도메인 로직이 외부 시스템이나 별도 엔진을 이용할 경우, 도메인 서비스 인터페이스를 활용해서 구현부를 인프라스트럭처 영역에 위치시킨다.
    - 도메인 서비스가 특정 기술에 종속되지 않는다.
    - 도메인 영역에 대한 테스트가 쉬워진다.