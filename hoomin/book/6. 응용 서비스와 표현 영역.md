#응용 서비스와 표현 영역

## 표현 영역과 응용 영역

- 사용자와 도메인을 연결해주는 매개체
- 표현영역
  - 사용자의 요청을 해석
- 응용영역
  - 서비스, 사용자가 원하는 기능을 제공
  - 표현 영역에 의존하지 않음

## 응용 서비스의 역할

- 도메인 객체를 사용해 사용자의 요청을 처리함
- 도메인 객체 간의 흐름을 제어하기 때문에 단순한 형태를 갖음
- 복잡하다면 도메인 로직의 일부를 구현하고 있을 가능성이 높다
    - 중복 코드 방지
    - 응집성 높임
        - 변경 용이성이 떨어짐

## 응용 서비스의 구현

- facade(디자인 패턴)
    - 서브시스템들의 공통적인 기능을 정의하는 단순화된 상위 수준의 인터페이스를 정의하는 패턴   
      서브시스템들 사이의 종속성을 줄일 수 있음
- 복잡한 로직 수행 x
- 한 클래스에 여러 기능 구현하기 vs 기능별로 서비스 클래스를 구현하기
    - 기능별로 서비스 클래스 구현하기, helper class(usecase??) 만들기
- 인터페이스 구현?
    - 한 인터페이스 상속하는 2개의 클래스 작성은 별로 없다
    - mockito 사용하면 클래스도 mock 생성 가능하므로 필요 없을 수 있다
    - 서비스의 기능을 인터페이스로 정의한다는 관점에서는 도움이 될 수도 있을 것 같다(3장에서 했던 얘기)
- 표현 영역에 의존하지 않기
    - 응용 계층과 표현 계층의 dto를 별개로 보지 않고 있음 (표현 영역의 구현 기술만 사용하지 않는것)
        - 테스트에는 문제 없기 때문에?
        - 표현 영역 변경되면 응용 서비스 구현도 함꼐 변경하는 문제는 발생
    - 표현 계층의 dto가 아닌 HtttpServletRequest나 HttpSession들만 표현영영과 관련된 타입으로 정의하고 있음

## 표현 영역

- 사용자가 시스템을 사용할 수 있는 흐름(화면)을 제공하고 제어
- 사용자의 요청을 알맞은 응용서비스에 전달하고 결과를 사용자에게 제공
- 사용자의 세션을 관리

## 값 검증

- 표현 영역과 응용 서비스 두 곳에서 모두 수행 가능
- 원칙적으로 응용 서비스에서 처리?(도메인이 제외?)
- 협의했던 내용
    - 표현 영역
        - 필수 값, 값의 형식, 범위 등 validator 최대한 화룡
    - 응용 영역
        - 여러 도메인 복합 검증시 활용
    - 도메인 영역
        - 논리적 오류, 도메인 안에서의 조합 검증
        - 필수 값, 값의 형식, 범위 등 중복 검증

## 권한 검사

- @PreAuthroize로 메소드 단위 권한 검증 활용 가능

## 조회 전용 기능과 응용 서비스

- 조회 전용 기능에는 응용서비스가 필요하지 않을 수 있따

