# 애그리거트

## 애그리거트

- 복잡한 도메인을 이해하고 관리하기 쉬운 상위 수준에서 바라보자
- 애그리거트 단위로 일관성을 관리하면 복잡도가 낮아진다
- 도메인 규칙과 요구사항으로 경계를 설정한다
    - 애그리거트에 속한 구성요소는 대부분 함께 생성, 제거하고 함께 변경되는 빈도가 높다
- 도메인에 대한 규칙을 제대로 이해할수록 애그리거트의 실제 크기는 줄어든다
    - 2 개 이상의 엔티티로 구성되는 애그리거트보다 1개의 엔티티로만 구성된 애그리거트가 많다.
- 최대한 서로 독립적이어야 한다(결합도가 높아질수록 수징 비용이 증가한다)

## 애그리거트 루트

- 애그리거트에 속한 모든 객체가 일관된 상태를 유지하도록 관리하는 책임이 있다
- 애그리거트에 속한 객체는 에그리거트 루트 엔티티에 직접, 간접적으로 속하게 된다
- 애그리거트가 제공해야 할 도메인 기능을 구현
  - 다른 객체를 조합해서 구현
- 애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하면 안 된다 (접근 제어자 변경 필요, 밸류 타입 불변)
- 상태 확인 후 변경과 같은 로직이 응용 서비스에 존재하는데 수정이 필요함
- 일급 컬렉션 활용시 외부에서 메소드 사용으로 값이 변할 수 있으니 불변 , 접근제어자 활용이 필요하다
- 트랜잭션 범위는 작을수록 좋다(성능 이슈)
- 한 트랜잭션에는 한 개의 에그리거트만 수정해야 한다
    - 부득이하개 2개 이상의 에그리거트 수정해야한다면 응용서비스에서 수정하도록 구현한다
        - 팀 표준으로 유스케이스 관련 기능으로 한 트랜잭션 실행 필요한 경우
        - 기술적으로 이벤트 방식 도입 불가능한 경우
        - UI로 한 번에 변경하고 싶은 경우
    
## 리포지터리와 애그리거트

- 애그리거트는 개념상 완전한 한 개의 도메인 모델을 표현
- 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재

## ID를 이용한 애그리거트 참조

- 에그리거트에 속한 객체가 다른 애그리거트 루트를 참조하면 편리하지만 문제를 야기한다
    - 편한 탐색 오용
        - 다른 객체 접근하면 애그리거트의 상태를 쉽게 변경 (트랜잭션 범위 오류)
        - 결합도를 높여서 변경이 어려워진다
    - 성능 이슈
    - 확장 어려움
        - RDS 부하 등의 이슈로 하위 도메인별로 시스템 분리(MSA 등 활용)
- ID 탐색으로 복잡도는 낮추며 지연로딩과 비슷한 결과
- 여러 애그리거트를 보여주려면 여러 리포지터리에서 select 해야한다 (join 못 사용)
    - 특정 조회 전용 리포지터리(DAO)에서 QueryDSL 사용하자

## 애그리거트 간 집합 연관

## 애그리거트를 팩토리로 사용하기

- 응용서비스 로직을 애그리거트로 옮겨 코드를 재사용하자
- 애그리거트가 다른 애그리거트 생성할때 직접 생성하지 않고 다른 팩토리에 위임하는 방법도 사용하자
    