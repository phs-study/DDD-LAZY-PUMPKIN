# 이벤트

## 시스템 간 강결합 문제

- 외부 결제 이용 환불 시스템 예시
	- 외부 api 실패시 롤백 해야함 (주문 취소 상태 변경하고 나중에 외부 api 사용하는 방식도 가능)
	- 외부 시스템 응답 시간이 길어지면 직접적인 영향을 받게됨
	- 도메인 객체에 서비스 전달시 서로다른 도메인 로직이 섞이는 문제 발생 (주문과 결제 로직)
	- 주문 바운디드 컨텍스트와 결제 바운디드 컨텍스트의 강결합이 문제
		- 비동기 이벤트로 해결 가능

## 이벤트 개요

- ~할 때, ~가 발생하면, 만약 ~하면, 도메인의 상태 변경
- 이벤트 생성 주체 - 이벤트 디스패처(퍼블리셔) - 이벤트 핸들러(구독자)
- 이벤트 생성 주체
	- 엔티티, 벨류, 도메인 서비스와 같은 도메인 객체
- 이벤트 정보
	- 이벤트 종류, 발생 시간, 이벤트 관련 정보(배송지 정보 등), 최소한의 데이터 포함
- 이벤트는 과거 시제 사용, 접미사로 Event 사용
- 이벤트 용도
	- 트리거, 도메인의 상태가 바뀔 때 후처리가 필요하면 트리거로 사용 가능
	- 서로 다른 시스템 간의 데이터 동기화
- 이벤트 장점
	- 서로 다른 도메인 로직이 섞이는 것을 방지
	- 이벤트 실행로직이기 때문에 기능 확장에도 용이

## 이벤트, 핸들러, 디스패처 구현

- 디스패처: ApplicationEventPublish 사용
- 같은 서버에서 이벤트이고, 같은 트랜잭션에서 실행하면 서비스 나눠서 (외부 api일때는 비동기 처리 추가)하는것에 비해 어떤 장점이 있는지?

> 외부 api 실행후 실패시 어떻게 처리할까? 비동기로 처리 / 이벤트와 트랜잭션 연계

## 비동기 이벤트 처리

- 비동기 처리가 가능한 요구사항에서 가능
- 로컬 핸들러 비동기 / 메시지 큐 사용 / 이벤트 저장소와 이벤트 포워더 / 이벤트 저장소와 이벤트 제공 API
- 로컬 핸들러 비동기
	- 이벤트 핸들러에 @Async 사용
- 메시지 큐 사용
	- 필요하면 이벤트 발생 도메인 기능과 메시지 큐에 이벤트 저장하는 절차를 한 트랜잭션으로 묶어야 함
		- 현재 메시지 큐에 이벤트 저장 시도까지만 트랜잭션
- 이벤트 저장소와 이벤트 포워더
	- 이벤트를 db에 저장한 뒤 포워더에서 이벤트를 주기적으로 읽어와 전달하고 어디까지 전달했는지 추적
- 이벤트 저장소와 이벤트 제공 API
	- 이벤트 제공 API가 이벤트 목록 제공 / 핸들러가 어디까지 처리했는지 추적

## 이벤트 적용시 고려 사항

- @TransactionalEventListener








