# 4.1 JPA 를 이용한 리포지터리 구현
## 4.1.1 모듈 위치
- 리포지터리 **인터페이스**는 애그리거트와 같이 `도메인 영역`에 속한다.
- 리포지터리를 **구현한 클래스**는 인프라 `스트럭처 영역`에 속한다.

# 4.1.2 리포지터리 기본 기능 구현
- 인터페이스는 `애그리거트 루트` 를 기준으로 작성한다.

>삭제 기능의 경우 요구사항이 있더라도 데이터를 실제로 삭제하는 경우는 많지 않다. 관리자 기능에서 삭제한 데이터까지 조회해야 하거나 데이터 원복을 위해 일정 기간 동안 보관해야 할 수 있기 떄문이다. 이 경우 삭제 플래그를 이용해 데이터를 화면에 보여줄 지에 대한 옵션을 주고 구현한다.

# 4.2 스프링 데이터 JPA 를 이용한 리포지터리 구현
- 스프링 데이터 JPA 를 이용하여 인터페이스를 정의하면 그 구현체가 스프링 빈에 등록되므로 직접 인터페이스를 구현하지 않아도 된다.
- 미리 구현된 쿼리 메서드를 잘 활용하자.

# 4.3 매핑 구현
## 4.3.1 엔티티와 밸류 기본 매핑 구현
- 한 테이블에 엔티티와 밸류 데이터가 같이 있을 경우
  - 밸류는 @Embeddable 로 매핑 설정
  - 밸류 타입의 프로퍼티는 @Embedded 로 매핑 설정
- 칼럼 이름 변경시 `@AttributeOverride` 사용

## 4.3.2 기본 생성자
- 불변 타입이므로 기본 생성자가 필요없지만 JPA 에서 @Entity 와 @Embeddable 로 클래스 매핑을 위해 기본 생성자가 필요함 
- JPA 의 기술적 제약으로 인해 불변 타입으로 쓰이는 밸류 타입도 기본 생성자를 추가해야 함.
- 기본 생성자 사용하면 온전하지 못한 객체를 사용하게 되기 떄문에 다른 코드에서 기본 생성자를 사용하지 못하도록 protected 로 선언한다.

## 4.3.3 필드 접근 방식 사용
JPA 의 필드 접근 방식
- 프로퍼티(@Access(AccessType.PROPERTY)) : getter/setter 구현해야 함.
- 필드(@Access(AccessType.FIELD))
- @Access 명시하지 않으면 @Id, @embedded 가 필드 혹은 메서드중 어디에 지정 되어있는지 확인후 접근 방식을 결정한다.

## 4.3.4 AttributeConverter 를 이용한 밸류 매핑 처리
- 두 개 이상의 프로퍼티를 가진 밸류 타입을 한개 칼럼에 매핑할 때 사용한다.
- 밸류 타입과 칼럼 데이터 간의 변환을 처리한다.
- AttributeConverter 를 구현한 클래스의 @Converter 애노테이션 의 밸류 값인 autoApply 에 따라 자동, 혹은 수동으로 converter 를 적용할 수 있다.

## 4.3.5 밸류 컬렉션 : 별도 테이블 매핑
- 하나의 엔티티에 여러 밸류 데이터를 가질 수 있는데, 이를 테이블로 분리하고, 외래키를 사용한다.
- 만약 밸류 데이터의 순서가 존재하여 List 로 구현했다면, 해당 컬렉션의 인덱스 값도 필요하므로, 분리한 테이블에 인덱스 값을 저장하는 칼럼도 저장할 수 있다.
  - 밸류 타입 객체에서는 굳이 index 를 갖는 프로퍼티가 필요없다. (List 타입 자체가 인덱스를 갖기 때문) 
  - `@OrderColumn` 을 이용하여 인덱스 값을 저장할 수 있다.
- `@ElementCollection` 과 `@CollectionTable` 을 함께 사용하여 매핑한다.

## 4.3.6 밸류 컬렉션 : 한 개 칼럼 매핑
- 하나의 엔티티에 여러 밸류 데이터를 가지지만, 테이블 분리하지 않고 콤마를 이용하여 하나의 필드로 저장할 수 있다.
- 이떄 AttributeConverter 를 사용한다. 단, 밸류 컬렉션을 표현하는 새로운 밸류 타입을 추가해야 한다.
  - ex : Set<Email> -> EmailSet (마치 일급 컬렉션)

## 4.3.7 밸류를 이용한 ID 매핑
- 식별자라는 의미를 부각시키기 위해 식별자 자체를 밸류 타입으로 만들 수 있다.
  - ex : OrderNo, MemberId
- `@Id` 대신 `@EmbeddedId` 애너테이션을 사용한다.
- **JPA 에서 식별자 타입은 Serializable 타입이어야 하므로 식별자로 사용할 밸류 타입은 Serializable 인터페이스를 상속 받아야 한다.**
- 식별자를 밸류 타입으로 이용하면 식별자에 기능을 추가할 수 있는 장점이 있다.
- JPA 에서 기본적으로 엔티티 비교를 위한 equals(), hashCode() 메서드를 사용하므로 밸류 타입에 대한 equals(), hashCode() 도 재정의가 필요하다.

## 4.3.8 별도 테이블에 저장하는 밸류 매핑
- 애그리거트에서 루트 엔티티를 뺸 나머지 구성요소는 대부분 밸류이다.
  - 또 다른 엔티티가 있다면 우선 엔티티인지 의심하자 -> 밸류일 가능성이 높다.
  - 엔티티가 확실하다면 해당 엔티티는 같은 애그리거트인지 확인하자 -> 다른 애그리거트일 가능성이 높다.
- 보통 엔티티 - 밸류는 고유 식별자로 구분한다. (단, 테이블의 PK와 착각하지 말자)
- JPA 에서는 별도 테이블로 밸류를 매핑할 경우 `@SecondaryTable` 과 `@AttributeOverride` 를 이용할 수 있다.
  - 두 테이블 조회시, 조인하여 데이터를 제공한다.
  - 근데, **조인할 필요없이 한 테이블에서만 데이터를 가져와도 되는 경우에는 밸류를 엔티티로 지정하여 지연 로딩방식을 사용해도 되지만 조회 전용 기능을 구현하는 방법이 좋다.**

## 4.3.9 밸류 컬렉션을 @Entity 로 매핑하기
- 개념적으로는 밸류지만 구현 기술의 한계, 혹은 팀 표준으로 인해 `@Entity` 를 사용해야 할 수 있다. (상속을 이용해야 함)
- 밸류이므로 상태 변경 메서드는 제공하지 않는다.
- 하이버네이트의 경우 clear() 메서드호출 시 삭제 과정이 효율적이지 않다.
  - 개별 엔티티에 대한 select 쿼리와 개별 엔티티 갯수만큼의 delete 쿼리가 나간다.
  - 따라서 애그리거트의 특성을 유지하면서 이 문제를 해결하기 위해 상속을 포기하고 @Embeddable 로 매핑된 단일 클래스로 밸류를 구현해야 한다.

## 4.3.10 ID 참조와 조인 테이블을 이용한 단방향 M:N 매핑
- 애그리거트간 집합 연관은 성능 상의 이슈로 피하는게 좋다.
- 하지만 구현에 있어서 집현 연관을 사용하는 것이 유리하다면 ID 참조를 이용하여 단방향 집합 연관을 적용해 볼 수 있다.
- 애그리거트를 직접 참조한다면 영속성 전이, 로딩 전략을 고민해야 하지만, ID 참조를 사용하므로 이런 문제를 생각하지 않아도 된다.

# 4.4 애그리거트 로딩 전략
- 애그리거트에 속한 객체가 모여야 완전한 하나가 된다. (애그리거트 루트를 로딩하면 루트에 속한 모든 객체가 완전한 상태여야 한다.)
- 애그리거트는 개념적으로 하나여야 하지만 루트 엔티티를 로딩하는 시점에 애그리거트에 속한 객체를 모두 로딩해야 하는 것은 아니다.
  - 따라서 상황에 맞게 즉시로딩과 지연로딩을 선택해야 한다.

# 4.5 애그리거트의 영속성 전파
- 저장 메서드는 애그리거트에 속한 모든 객체를 저장해야 한다.
- 삭제 메서드는 애그리거트에 속한 모든 객체를 삭제해야 한다.
- @Embeddable 매핑 타입의 경우 함께 저장되고 삭제되므로 cascade 속성을 추가로 설정하지 않아도 된다. (@Entity 매핑은 cascade 속성을 설정해야한다.)

# 4.6 식별자 생성 기능
- 식별자 생성 방식
  - 사용자가 직접 생성
  - 도메인 로직으로 생성
  - DB 를 이용한 일련번호 사용
- 식별자 생성 규칙은 도메인 규칙이므로 도메인 영역에서 생성 기능을 위치시킨다.

# 4.7 도메인 구현과 DIP
- 도메인 영역에 @Entity, @Table 과 같은 JPA 애노테이션을 사용하게 되면서 도메인이 인프라 구현 기술에 의존하고 있다.
- 이는 DIP 를 지키지 못한다. (고수준 모듈인 도메인 영역이 세부 구현 기술인 인프라 영역을 의존하게 된다.)
- 그러나 개발 편의성과 실용성을 가져가고 구현 기술에 따른 제약이 낮다면 DIP 를 꼭 지키지 못해도 좋다.