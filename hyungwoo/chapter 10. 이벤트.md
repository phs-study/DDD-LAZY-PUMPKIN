# 10.1 시스템 간 강결합 문제

- 결제시스템의 경우 우리 서비스의 외부에 존재함.
- 이때 두가지 문제가 발생할 수 있음.
  - 외부서비스가 정상이 아닐 경우 트랜잭션 처리가 애매함.
  - 성능이 느려질 수 있다.

- 도메인 객체에 서비스를 전달하면 추가로 설계상 문제가 나타날 수 있다.
  - ex) 주문을 표현하는 도메인인데, 주문 로직과 결제 로직이 섞일 수 있다.
  - 기능을 추가할 때 다른 서비스를 파라미터로 또 받아야 할 수도 있다..

- 이러한 예시 문제는 주문 바운디드 컨텍스트와 결제 바운디드 컨텍스트 간의 강결합 때문이다.
  - 이벤트를 사용하면 이러한 강한 결합을 없앨 수 있다. (특히 비동기 이벤트를 사용하면 두 시스템 간의 결합을 크게 낮출 수 있음.)

# 10.2 이벤트 개요

- 이벤트 : 과거에 벌어진 어떤 것
- 이벤트가 발생한다 -> 상태가 변경됐다.
- 이벤트가 발생하면 이벤트에 반응하여 원하는 동작을 수행하는 기능을 구현한다.

## 10.2.1 이벤트 관련 구성요소

- 도메인 모델에 이벤트를 도입하려면 다음 네 개의 구성요소를 구현해야 한다.
  - 이벤트
  - 이벤트 생성 주체
    - 도메인 모델에서 이벤트 주체는 `도메인 객체`이다.
    - 이벤트를 디스패처에 전달한다.
  - 이벤트 디스패처 (퍼블리셔)
    - 이벤트 생성 주체와 이벤트 핸들러를 연결해 준다.
    - 이벤트를 핸들러로 전달한다.
    - 구현 방식에 따라 이벤트 생성과 처리를 동기, 비동기로 실행하게 된다.
  - 이벤트 핸들러 (구독자)
    - 이벤트 생성 주체가 발생한 이벤트에 반응한다. -> 이벤트를 전달받아 이벤트에 담긴 데이터를 이용해서 원하는 기능을 실행한다.


## 10.2.2 이벤트의 구성

- 이벤트에 대한 정보는 다음과 같다.
  - 이벤트 종류 : 클래스 이름으로 이벤트 종류를 표현
  - 이벤트 발생 시간
  - 추가 데이터 : 주문번호, 신규 배송지 정보 등 이벤트와 관련된 정보

- 이벤트는 현재 기준으로 과거에 벌어진 것을 표현하므로 과거 시제를 사용한다.
- Event.raise() 를 통해 디스패처에 이벤트를 전파할 수 있다.
- 이벤트 핸들러는 디스패처를 통해 이벤트를 전달받아 필요한 작업을 수행한다. `@EventListenener(이벤트클래스이름.class)` 를 사용한다.
- 이벤트에 작업을 수행할 데이터를 담아야 핸들러가 필요한 데이터를 이용하여 처리를 할 수 있다.
  - 이벤트와 관련 없는 데이터를 포함할 필요는 없다.

## 10.2.3 이벤트 용도

- 크게 두 가지 용도로 쓰인다.
  - 트리거
    - 도메인 상태가 바뀔 때 다른 후처리가 필요하면 후처리를 실행하기 위한 트리거로 이벤트를 사용할 수 있다.
    - ex) 예매 결과를 SMS 로 통지한다 -> 예매 도메인은 예매 완료 이벤트를 발생시키고 이 이벤트 핸들러에서 SMS 를 발송하는 방식으로 구현할 수 있다.
  - 서로 다른 시스템 간의 동기화
    - 배송지를 변경하면 외부 배송 서비스에 바뀐 배송지 정보를 전송해야 한다. -> 이벤트를 통해 외부 배송 서비스와 배송지 정보를 동기화 할 수 있다.

## 10.2.4 이벤트의 장점

- 서로 다른 도메인 로직이 섞이는 것을 방지할 수 있다.
  - ex) 구매 취소에 더이상 환불 로직이 없다. (서비스를 넘겨 받지 않아도 된다.) -> 결제 도메인으로의 의존을 제거할 수 있게 된다.
- 기능 확장이 용이하다.
  - ex) 구매 취소시 환불과 함께 이메일로 취소 내용을 보내고 싶다면 이메일 발송을 처리하는 핸들러를 구현하면 된다. 이때, 구매 취소 로직은 수정할 필요가 없다.


# 10.3 이벤트, 핸들러, 디스패처 구현

## 10.3.1 이벤트 클래스
- ex) OrderCanceledEvent
  - 과거시제여야 함.
  - 처리에 필요한 데이터 포함해야 함.
- 모든 이벤트가 공통으로 갖는 프로퍼티가 있다면 상위 클래스를 만들 수 있다.
  - ex) 이벤트 발생시간 -> timestamp 를 갖는 추상클래스를 만들고 해당 상위 클래스를 상속받는다.

## 10.3.2 Events 클래스와 ApplicationEventPublisher
- 스프링이 제공하는 ApplicationEventPublisher 를 사용한다.
- Events 클래스에서 ApplicationEventPublisher 를 주입받아서 publishEvent 를 사용하는 raise 메서드를 구현한다. 
- raise 메서드를 통해 이벤트를 발생시킬 수 있다.


## 10.3.3 이벤트 발생과 이벤트 핸들러
- 이벤트 발생시킬 코드는 Events.raise() 메서드를 사용한다.
- 이벤트를 처리할 핸들러는 스프링이 제공하는 `@EventListener` 애너테이션을 사용해서 구현한다.
- 이벤트 핸들러는 응용 서비스와 동일한 트랜잭션 범위에서 이벤트를 실행된다.

# 10.4 동기 이벤트 처리 문제

- 이벤트를 통해 강결합 문제는 해소했지만 한가지 문제가 남음. -> 외부 서비스에 영향을 받는 문제
  - 외부 서비스로 인한 성능 저하가 생길 수 있음.
  - 외부서비스 요청 실패시 트랜잭션 롤백할지 말지 애매해짐.
    - 이벤트를 비동기로 처리하거나 이벤트와 트랜잭션을 연계한다.

# 10.5 비동기 이벤트 처리
- A 하면 이어서 B 하라 -> A 하면 최대 언제까지 B 하라
  - 이벤트를 비동기로 처리하는 방식으로 구현할 수 있다.
  - A 이벤트가 발생하면 별도 스레드로 B를 수행하는 핸들러를 실행하는 방식으로 요구사항을 구현할 수 있다.
  
- 이벤르를 비동기로 처리하는 방식
  - 로컬 핸들러를 비동기로 실행하기
  - 메시지 큐를 사용하기
  - 이벤트 저장소와 이벤트 포워더 사용하기
  - 이벤트 저장소와 이벤트 제공 API 사용하기

## 10.5.1 로컬 핸들러 비동기 실행
- 이벤트 핸들러를 비동기로 실행하는 방법은 이벤트 핸들러를 별도 스레드로 실행하는 것이다.
- 스프링이 제공하는 @Async 애너테이션을 사용한다.
  - @EnableAsync 애너테이션을 사용해서 비동기 기능을 활성화 한다.
  - 이벤트 핸들러 메서드에 @Async 애너테이션을 붙인다.

## 10.5.2 메시징 시스템을 이용한 비동기 구현

- 카프카나 래빗MQ 와 같은 메시징 시스템을 이용한다.
- 이벤트가 발생하면 메시지를 큐에 보낸다. -> 메시지 큐는 이벤트를 메시지 리스너에 전달하고, 메시지 리스너는 알맞은 이벤트 핸들러를 이용해서 이벤트를 처리한다.
- 이벤트를 메시지 큐에 저장하는 과정 / 메시지 큐에서 이벤트를 읽어와 처리하는 과정은 별도 스레드나 프로세스로 처리한다.
  - 이벤트 발생 JVM 과 이벤트 처리 JVM 이 다르다.
  - 같은 JVM 에서 메시지 큐를 이용해서 이벤트를 주고받을 수는 있지만 시스템을 복잡하게 만들 뿐임.
- 필요에 따라 이벤트를 발생시키는 도메인 기능과 메시지 큐에 이벤트를 저장하는 절차를 한 트랜잭션에 묶어야 한다.
  - 글로벌 트랜잭션이 필요하다.
  - 안전하게 이벤트를 메시지 큐에 전달할 수 있는 장점이 있다.
  - 전체 성능이떨어지는 단점이 있다.
  - 글로벌 트랜잭션을 지원하지 않는 메시징 시스템도 있다.

- 래빗MQ 와 같은 메시징 시스템은 글로벌 트랜잭션 지원과 함께 클러스터와 고가용성을 지원하기 때문에 안정적으로 메시지를 전달할 수 있는 장점이 있다.
  - 다양한 개발 언어와 통신 프로토콜을 지원하고 있다.
- 카프카는 글로벌 트랜잭션을 지원하지는 않는다.
  - 다른 메시징 시스템에 비해 높은 성능을 보여준다.

## 10.5.3 이벤트 저장소를 이용한 비동기 처리
- 이벤트를 일단 DB 에 저장하고 별도 프로그램을 이용해서 이벤트 핸들러에 전달하는 방식이다.

- 포워더 방식
  - 포워더는 이벤트를 주기적으로 읽어와 어디까지 전달했는지 추적한다.
    - 포워더는 별도 스레드를 이용하므로 이벤트 발행과 처리가 비동기로 처리된다.
  - 도메인의 상태와 이벤트 저장소로 동일한 DB 를 사용한다.
    - 이벤트가 물리 저장소에 보관되므로 핸들러가 이벤트 처리에 실패하면 포워더는 다시 이베트 저장소에서 이벤트를 읽어와서 핸들러를 실행하면 된다.

- API 방식
  - 외부 핸들러가 API 서버를 통해 이벤트 목록을 가져간다.
  - 외부 핸들러 자신이 어디까지 이벤트를 처리했는지 기억해야 한다.

# 10.6 이벤트 적용 시 추가 고려 사항

- 이벤트 소스를 EventEntry 에 추가할지 여부를 정해야 한다.
  - 앞서 구현한 EventEntry 에는 이벤트 발생 주체에 대한 정보를 갖지 않는다.
  - 따라서 `ex) Order 가 발생시킨 이벤트만 조회하기` 처럼 특정 주체가 발생시킨 이벤트만 조회하는 기능을 구현할 수 없다. -> 이벤트 발생 주체 정보를 추가해야 한다.
- 포워더에 전송 실패를 얼마나 허용할 것이냐 정해야 한다.
  - 포워더는 이벤트 정송 실패시 실패한 이벤트 부터 다시 읽어와 전송을 시도한다.
  - 만약 특정 이벤트에서 계속 전송 실패하면 그 이벤트 때문에 나머지 이벤트를 전송할 수 없게 된다.
  - 따라서 포워더 구현시 실패한 이벤트의 재전송 횟수 제한을 둬야 한다. (제한 횟수를 넘어서면 다른 이벤트로 넘어가는 등의 정책이 필요)
  - 이벤트를 생략하지 않고 실패용 DB 나 메시지 큐에 저장하기도 한다. -> 추후 실패 이유 분석이나 후처리에 도움이 된다.
- 이벤트 손실 처리
  - 이벤트 저장소를 이용하면 이벤트 발생과 저장을 한 트랜잭션에서 이루어지기 때문에 이벤트 유실 걱정이없다.
  - 로컬 핸들러를 이용하여 이벤트를 비동기로 처리하면 이벤트 처리 실패시 이벤트가 유실된다.
- 이벤트 순서에 대한 처리
  - 이벤트 발생 순서대로 외부 시스템에 전달해야 한다면 이벤트 저장소를 사용하는게 좋다.
    - 이벤트 저장소에 이벤트를 순서대로 저장하기 때문
    - 메시징 시스템을 사용한다면 기술에 따라 이벤트 발생순서와 메시지 전달 순서가 달라질 수 있다.
- 이벤트 재처리
  - 동일한 이벤트를 다시 처리해야할 때 이벤트를 어떻게 해야할지 결정해야 한다.
  - 가장 간단한 방법은 마지막으로 처리한 이벤트 순번을 기억했다가 이미 처리한 순번의 이벤트가 도착하면 해당 이벤트를 처리하지 않고 무시하는 방법이다.
  - 이벤트를 멱등으로 처리하는 방법도 있다.
    - 동일 이벤트를 여러번 적용해도 시스템이 같은 상태가 되도록 핸들러를 구현할 수 있다.
    - 시스템 장애로 인해 이벤트가 중복해서 발생해도 결과적으로 동일 상태가 되므로 이벤트 중복발생, 중복 처리에 대한 부담을 줄여준다.

## 10.6.1 이벤트 처리와 DB 트랜잭션 고려
- 이벤트 처리시 DB 트랜잭션을 함께 고려해야 한다.
- 이벤트 처리를 동기로 하든 비동기로 하든 이벤트 처리 실패와 트랜잭션 실패를 함께 고려해야 한다.
  - 두 실패를 한번에 고려하면 복잡해지므로 경우의 수를 줄이면 도움이 된다.
    - 경우의 수를 줄이는 방법은 트랜잭션이 성공할 때만 이벤트 핸들러를 실행하는 것이다.
  - 스프링은 `@TransactionalEventListener` 애너테이션을 지원한다.
    - 스프링의 트랜잭션 상황에 따라 이벤트 핸들러를 실행할 수 있게 한다.
    - phase 의 속성값인 TransactionPhase.AFTER_COMMIT 을 지정하면 스프링 트랜잭션 커밋이 성공한 뒤에 핸들러 메서드를 실행한다.
  - 이벤트 저장소로 DB 를 사용해도 동일한 효과를 얻을 수 있다.
    - 이벤트 발생 코드와 이벤트 저장 처리를 한 트랜잭션으로 처리하면 트랜잭션이 성공할 때만 이벤트가 DB 에 저장되므로 트랜잭션이 실패했는데 이벤트 핸들러가 실행되는 상황은 발생하지 않는다.
- 이제, 트랜잭션이 성공할 때만 이벤트 핸들러가 실행하므로, 트랜잭션 실패에 대한 경우의 수를 생각할 필요 없이, 이벤트 처리 실패만 고민하면 된다.
  - 이벤트 특성에 따라 재처리 방식을 결정하면 된다.


