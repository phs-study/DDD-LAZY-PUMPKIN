# 5.1 시작에 앞서
- CQRS : 명령(Command)모델과 조회(Query)모델을 분리하는 패턴이다.
- 명령 모델 : 상태를 변경하는 기능을 구현할 때 사용 ex) 회원 가입, 암호 변경, 주문 취소
  - 도메인 모델(엔티티, 애그리거트, 리포지터리)은 명령 모델로 주로 사용됨
- 조회 모델 : 데이터를 조회하는 기능을 구현할 때 사용 ex) 주문 목록, 주문 상세

# 5.2 검색을 위한 스펙
- 목록 조회와 같이 다양한 검색 조건을 조합할 때 find 메서드를 매번 정의하는 것은 좋은 방법이 아니다.
- 이때 스펙을 사용한다. 스펙은 애그리거트가 특정 조건을 충족하는지를 검사할 때 사용하는 **인터페이스**이다.
```java
public interface Specification<T> {
  public boolean isSatisfiedBy(T agg);
}
```

isSatisfiedBy 메서드의 agg 파라미터는 검사 대상이 되는 객체이다.
- 해당 스펙 인터페이스를 리포지터리에서 사용하면 agg 는 애그리거트 루트가 된다.
- 해당 스펙 인터페이스를 DAO 에 사용하면 agg 는 검색 결과로 리턴할 데이터 객체가 된다.

실제로 모든 애그리거트 객체를 메모리에 보관하기 어렵기에 실제로 스펙은 사용하는 기술에 맞춰 구현해야 한다.

# 5.3 스프링 데이터 JPA 를 이용한 스펙 구현
- 스펙 구현 시 JPA 정적 메타 모델을 이용하면 프로퍼티에 대한 메타 모델을 이용한다.
- 문자열로 프로퍼티를 지정하는 것보다 안정적이고 생산성 측면에서 유리하다.

# 5.4 리포지터리/DAO 에서 스펙 사용하기
생략

# 5.5 스펙 조합
- 구현된 스펙을 .and(), .or(), .not(), .where() 를 이용하여 적절히 사용한다.

# 5.6 정렬 지정하기
- 쿼리메서드를 이용하거나 Sort 객체를 퍄라미터로 넘긴다.

# 5.7 페이징 처리하기
- findBy 프로퍼티형식에 Pageable 타입을 사용하더라도 리턴타입이 List 이면 카운트 쿼리가 실행되지 않음
- 스펙을 사용하는 findAll 메서드의 경우에는 리턴타입이 List 라도 카운트 쿼리가 실행된다.
  - 페이징 정복 필요 없다면 굳이 카운트 쿼리를 날리지 않는 방향을 선택하자.

# 5.8 스펙 조합을 위한 스펙 빌더 클래스
- 여러 조건에 따른 스펙을 조합할 경우 `스펙 빌더`를 사용한다.
- 메서드 체이닝을 이용하기 때문에 역속된 변수 할당을 줄여줘서 코드 가독성을 높이고 구조가 단순해진다.

# 5.9 동적 인스턴스 생성
- 쿼리 결과에서 임의의 객체를 동적으로 생성할 수 있다.
- @Query("select new ~.~.A(a,b,c,d)) 로 select 절에 new 키워드와 패키지, 생성할 인스턴스 생성자를 지정하여 동적으로 인스턴스화 할 수 있다.

# 5.10 하이버네이트 @Subselect 사용
- select 쿼리의 결과를 매핑할 테이블처럼 사용한다.
- @Subselect 로 조회한 @Entity 는 수정할 수 없다.


