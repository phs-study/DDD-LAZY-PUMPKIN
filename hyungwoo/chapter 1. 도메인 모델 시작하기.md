# 1.1 도메인이란?

도메인 : 소프트웨어로 해결하고자 하는 문제 영역

도메인은 여러 하위 도메인으로 구성된다.

특정 도메인을 위한 소프트웨어라고 해서 도메인이 제공해야할 모든 기능을 직접 구현하는 것이 아님. (외부 시스템을 사용한다.)

도메인 마다 고정된 하위 도메인이 존재하는 것은 아니다. (상황에 따라 다르다.)

# 1.2 도메인 전문가와 개발자 간 지식 공유

도메인 전문가 : 각 영역의 전문가 (비 개발자)

개발자는 요구사항을 올바르게 이해해야 옳바른 제품을 만들 수 있다.

요구사항을 올바르게 이해하려면 개발자와 전문가가 `직접 대화` 해야 한다.

"Garbage in, Garbage out" 을 줄이기 위해서 개발자와 도메인 전문가는 직접 소통한다. 직접 소통할 수록 변질될 가능성이 줄어든다.

또, 대화를 하면서 그들이 원하는 실체를 조율하고 찾아내야 한다.

# 1.3 도메인 모델

도메인 모델 : 특정 도메인을 개념적으로 표현한 것 (ex : 주문 모델) -> 도메인 자체를 이해하기 위핸 개념 모델이다.

도메인 모델을 사용하면 여러 관계자들이 동일한 모습으로 도메인을 이해하고 도메인 지식을 공유하는데 도움이 된다.



![image-20220824013009386](https://user-images.githubusercontent.com/52458039/186219364-2235ccd5-aaf7-45f8-a02b-25cfcce27507.png)

위 그림은 객체를 이용한 도메인 모델이다.

도메인을 이해하기 위해 도메인이 제공하는 기능 & 도메인의 주요 데이터를 파악해야하는데, 이러한 객체 모델은 도메인을 이해하고 모델링 하기에 적합하다.

![image-20220824013403920](https://user-images.githubusercontent.com/52458039/186219464-3ee02dac-b19b-4964-b20e-e1ecf7a80920.png)

상태 다이어 그램을 이용하여 주문에 대한 도메인 모델링을 할 수도 있다.

도메인 모델에 따라 꼭 위와 같이 UML 표기법을 사용하는게 아니라 여러 방식으로 모델링할 수 있다. (ex : 그래프, 수학 공식 ..)

> 도메인은 다수의 하위 도메인으로 구성된다. 하위 도메인이 다루는 영역은 서로 다르기 때문에 같은 용어라도 하위 도메인마다 의미가 달라질 수 있다. 모델의 각 구성요소는 특정 도메인으로 한정할 때 비로소 의미가 완전해지기 때문에 각 하위 도메인마다 별도로 모델을 만들어야 한다.

# 1.4 도메인 모델 패턴

도메인 모델 패턴 : 아키텍처 상의 도메인 계층을 객체 지향 기법으로 구현하는 패턴

도메인 계층은 도메인의 `핵심 규칙`을 구현한다.

ex : 주문 도메인 규칙 -> "출고 전에 배송지를 변경 할 수 있다" + "주문 취소는 배송 전에만 할 수 있다."

해당 규칙을 구현한 코드는 도메인 계층에 위치하게 된다.

> 개념 모델 : 순수하게 문제를 분석한 결과물. 데이터베이스, 트랜잭션 처리, 성능, 구현 기술을 고려하고 있지 않음. 따라서 실제 코드를 작성할 때 개념 모델을 그대로 사용할 수 없음. 도메인에 대한 새로운 지식이 쌓이면서 모델을 보완하거나 변경 하는 일이 발생하고, 이러한 내용들이 모여 도메인에 대한 전체 윤곽을 이해할 수 있다.
>
> 구현 모델 : 잘 잡혀있는 개념 모델을 기반으로 구현 가능한 형태의 모델로 전환 및 구현한다.

# 1.5 도메인 모델 도출

기획서, 유스케이스, 사용자 스토리와 같은 요구사항과 관련자와의 대화를 통해 도메인을 이해하고 이를 바탕으로 도메인 모델 초안을 만들어야 비로소 코드를 작성할 수 있다.
화이트보드, 종이 or 연필, 모델링 툴 등 어떤 것을 선택하든, 구현을 시작하려면 도메인에 대한 `초기 모델`이 필요하다.

도메인 모델링의 기본 작업 : 모델을 구성하는 핵심 구성요소, 규칙, 기능을 찾는다. (이는 요구사항에서 출발한다.)

예를 들어, 주문 도메인을 살펴본다.

## 주문 도메인 요구사항
- (1) 최소 한 종류 이상의 상품을 주문해야 한다.
- (2) 한 상품을 한 개 이상 주문할 수 있다.
- (3) 총 주문 금액은 각 상품의 구매 가격 합을 모두 더한 금액이다.
- (4) 각 상품의 구매 가격 합은 상품 가격에 구매 개수를 곱한 값이다.
- (5) 주문할 때 배송지 정보를 반드시 지정해야 한다.
- (6) 배송지 정보는 받는 사람 이름, 전화번호, 주소로 구성된다.
- (7) 출고를 하면 배송지를 변경할 수 없다.
- (8) 출고 전에 주문을 취소할 수 있다.
- (9) 고객이 결제를 완료하기 전에는 상품을 준비하지 않는다.



(2) 와 (4) 를 통해 주문 항목을 표현 하는 OrderLine 에 주문할 상품, 상품의 가격, 구매 개수를 포함해야 한다.
(1) 와 (3) 을 통해 Order 와 OrderLine 관계를 정할 수 있다. (Order 생성시 OrderLine 이 반드시 1개 이상 있어야 하고, OrderLine 에서 상품의 총 금액을 계산할 수 있다.)
(5) 를 통해 Order 생성 시 ShippingInfo 도 함께 생성 되야 한다.
(7) 과 (8), (9) 는 주문 도메인의 제약과 규칙에 해당한다.

## 주문 도메인 기능 목록
- Order 객체
    - 주문 상품들, 배송지 정보, 주문 상태, 주문 금액 정보를 가진다.
    - 주문 배송지를 변경할 수 있다.
    - 주문을 취소할 수 있다.
    - OrderLine 객체
        - 상품 종류, 상품의 가격, 상품을 주문한 갯수, 해당 주문의 총 금액 정보를 가진다.
        - 구매한 상품 총 가격을 계산할 수 있다.
    - ShippingInfo 객체
        - 주문자 이름, 주문자 휴대폰 번호, 주문자 배송지 1, 주문자 배송지 2, 주문자 우편 번호에 대한 정보를 가진다.
    - OrderState 객체
        - 결제 대기, 주문 진행 중, 선적 중, 배송 중, 배송 완료, 주문 취소 에 대한 상태를 가진다.

이렇게 요구사항을 분석하며 도메인 모델을 점진적으로 만들어 나갈 수 있다. (이름 정도만 정하거나, 코드 수준이라면 간단히 작성 하게 만들어 보는 정도)

>이렇게 도메인 초기 모델을 정한 것을 도메인 전문가나 다른 개발자에게 공유하기 위해 문서화를 잘 해놔야 한다. 코드만으로 소프트웨어를 분석하려면 많은 시간이 필요하다. 따라서 코드 수준 보다 상위  수준에서 정리한 문서를 참조하는 것이 소프트웨어 전반을 빠르게 이해하는데 도움이 된다. 전체 구조를 이해하고 더 깊게 이해할 필요가 있는 부분을 코드로 분석해 나가면 된다.<br> 
>코드를 보면 도메인을 더 깊게 이해하게 되므로 코드 자체도 문서화의 대상이 된다.

# 1.6 엔티티와 밸류
도출한 도메인 모델은 크게 **엔티티(Entity)**와 **밸류(Value)**로 구분할 수 있댜.

## 엔티티(Entity)
엔티티의 가장 큰 특징은 식별자를 가진다는 것이다. 
엔티티 객체들은 서로 고유한 식별자를 갖는다.

### 식별자 생성 규칙
- 특정 규칙에 따라 생성 (ex 주문번호, 운송장번호, 카드번호 -> 회사마다 다름)
- UUID 나 Nano ID 와 같은 고유 식별자 생성기 사용 (Nano ID 참고 사이트 : https://zelark.github.io/nano-id-cc/)
- 값을 직접 입력 (중복 입력하지 않도록 사전에 방지가 필요)
- 일련번호 사용(시퀀스나 DB 의 자동 증가 칼럼 사용)


## 밸류 타입(Value Type)
개념적으로 완전한 하나를 표현할 때 사용한다.
ex) ShippingInfo
```java
public class ShippingInfo {
    // 받는 사람
    private String receiverName; 
    private String receiverPhoneNumber;
    
    // 주소
    private String shippingAddress1;
    private String shippingAddress2;
    private String shippingZipcode;
}
```

이름과 전화번호는 `받는 사람` 이라고 개념적인 하나로 표현할 수 있다.
주소1, 주소2, 우편번호 는 '배송 정보' 라고 개념적인 하나로 표현할 수 있다.

밸류타입을 꼭 두 개 이상의 데이터를 가져야 하는건 아님. 의미를 명확하게 표현하기 위해 하나의 데이터를 밸류 타입으로 사용하는 경우도 있음.
ex : Money

```java
public class Money {
    private int value;

    public Money(int value) {
        this.value = value;
    }

    public int getValue() {
        return value;
    }

    public Money add(Money money) {
        return new Money(this.value + money.value);
    }

    public Money multiply(int multiplier) {
        return new Money(this.value * multiplier);
    }
}
```
가격이라는 데이터를 Money 라는 객체 밸류타입으로 만들었다.
이렇게 하면 `돈` 이라는 의미를 명확하게 할 수 있고 밸류 타입을 위한 기능을 추가할 수 있다는 장점이 있다.

밸류 타입은 불변으로 구현하는데, 그 이유는 데이터 변경이 되지 않음을 보장하기에 예기치 못한 문제가 생기지 않는 안전한 코드를 작성할 수 있다.
>50p 불변이라면 객체의 필드 값을 final 로 해야하는게 아닌가..

## 엔티티의 식별자와 밸류 타입
엔티티의 식별자를 밸류 타입을 사용할 수 있다. (의미가 더 명확)
ex : Order 의 식별자 타입을 String -> OrderNo 밸류 타입 사용

## 도메인 모델에 set 메서드 넣지 않기
도메인 모델에 set 메서드를 추가하는 것은 도메인의 핵심 개념이나 의도를 코드에서 사라지게 한다.
- 필드 값만 변경하기에 도메인 모델의 상태 변경(도메인 규칙에 따라 다름)과 관련된 모데인 지식이 코드에서 사라진다.
- 도메인 객체를 생성할 때 온전하지 않은 상태가 될 수 있음. (특정 필드만 변경하므로 도메인 규칙에 따른 수정이 동시에 일어나지 못해서 생기는 문제)

즉, set 메서드를 사용하지 않고, 객체 생성 시점에 생성자를 통해 필요한 데이터를 모두 받아야 한다.


# 1.7 도메인 용어와 유비쿼터스 언어
코드를 도메인 용어로 작성하면 코드의 가독성을 높여서 코드를 분석하고 이해하는 시간을 줄여준다.
알맞은 도메인 용어를 표현하기 위해 적당한 영단어를 찾는 노력이 필요하다.